// AUTOGENERATED COPYRIGHT HEADER START
// Copyright (C) 2020-2023 Michael Fabian 'Xaymar' Dirks <info@xaymar.com>
// AUTOGENERATED COPYRIGHT HEADER END

#include "amf.hpp"
#include "common.hpp"
#include "strings.hpp"
#include "encoders/codecs/av1.hpp"
#include "encoders/codecs/h264.hpp"
#include "encoders/codecs/hevc.hpp"
#include "encoders/encoder-ffmpeg.hpp"
#include "ffmpeg/tools.hpp"
#include "plugin.hpp"

#include "warning-disable.hpp"
extern "C" {
#include <libavutil/opt.h>
}
#include "warning-enable.hpp"

#define ST_I18N "Encoder.FFmpeg.AMF"
#define ST_KEY_USAGE "Usage"
#define ST_I18N_USAGE ST_I18N ".Usage"
#define ST_I18N_USAGE_(x) ST_I18N_USAGE "." D_VSTR(x)
#define ST_KEY_QUALITY "Quality"
#define ST_I18N_QUALITY ST_I18N ".Quality"
#define ST_I18N_QUALITY_(x) ST_I18N_QUALITY "." D_VSTR(x)
#define ST_I18N_RATECONTROL ST_I18N ".RateControl"
#define ST_KEY_RATECONTROL "RateControl"
#define ST_I18N_RATECONTROL_MODE ST_I18N_RATECONTROL ".Mode"
#define ST_I18N_RATECONTROL_MODE_(x) ST_I18N_RATECONTROL_MODE "." D_VSTR(x)
#define ST_KEY_RATECONTROL_MODE ST_KEY_RATECONTROL ".Mode"
#define ST_I18N_RATECONTROL_PREENCODE ST_I18N_RATECONTROL ".PreEncode"
#define ST_KEY_RATECONTROL_PREENCODE ST_KEY_RATECONTROL ".PreEncode "
#define ST_I18N_RATECONTROL_LIMITS ST_I18N_RATECONTROL ".Limits"
#define ST_KEY_RATECONTROL_LIMITS ST_KEY_RATECONTROL ".Limits"
#define ST_I18N_RATECONTROL_LIMITS_BUFFERSIZE ST_I18N_RATECONTROL_LIMITS ".BufferSize"
#define ST_KEY_RATECONTROL_LIMITS_BUFFERSIZE ST_KEY_RATECONTROL_LIMITS ".BufferSize"
#define ST_I18N_RATECONTROL_LIMITS_QUALITY ST_I18N_RATECONTROL_LIMITS ".Quality"
#define ST_KEY_RATECONTROL_LIMITS_QUALITY ST_KEY_RATECONTROL_LIMITS ".Quality"
#define ST_I18N_RATECONTROL_LIMITS_BITRATE ST_I18N_RATECONTROL_LIMITS ".Bitrate"
#define ST_KEY_RATECONTROL_LIMITS_BITRATE ST_KEY_RATECONTROL_LIMITS ".Bitrate"
#define ST_I18N_RATECONTROL_LIMITS_BITRATE_TARGET ST_I18N_RATECONTROL_LIMITS_BITRATE ".Target"
#define ST_KEY_RATECONTROL_LIMITS_BITRATE_TARGET ST_KEY_RATECONTROL_LIMITS_BITRATE ".Target"
#define ST_I18N_RATECONTROL_LIMITS_BITRATE_MAXIMUM ST_I18N_RATECONTROL_LIMITS_BITRATE ".Maximum"
#define ST_KEY_RATECONTROL_LIMITS_BITRATE_MAXIMUM ST_KEY_RATECONTROL_LIMITS_BITRATE ".Maximum"
#define ST_I18N_RATECONTROL_QP ST_I18N_RATECONTROL ".QP"
#define ST_KEY_RATECONTROL_QP ST_KEY_RATECONTROL ".QP"
#define ST_I18N_RATECONTROL_QP_I ST_I18N_RATECONTROL_QP ".I"
#define ST_KEY_RATECONTROL_QP_I ST_KEY_RATECONTROL_QP ".I"
#define ST_I18N_RATECONTROL_QP_P ST_I18N_RATECONTROL_QP ".P"
#define ST_KEY_RATECONTROL_QP_P ST_KEY_RATECONTROL_QP ".P"
#define ST_I18N_RATECONTROL_QP_B ST_I18N_RATECONTROL_QP ".B"
#define ST_KEY_RATECONTROL_QP_B ST_KEY_RATECONTROL_QP ".B"

#define ST_I18N_PA ST_I18N ".PreAnalysis"
#define ST_KEY_PA "PreAnalysis"
#define ST_I18N_PA_LOOKAHEAD ST_I18N_PA ".LookAhead"
#define ST_KEY_PA_LOOKAHEAD ST_KEY_PA ".LookAhead"
#define ST_I18N_PA_SCENECHANGEDETECTION ST_I18N_PA ".SceneChangeDetection"
#define ST_KEY_PA_SCENECHANGEDETECTION ST_KEY_PA ".SceneChangeDetection"
#define ST_I18N_PA_STATICSCENEDETECTION ST_I18N_PA ".StaticSceneDetection"
#define ST_KEY_PA_STATICSCENEDETECTION ST_KEY_PA ".StaticSceneDetection"
#define ST_I18N_PA_ACTIVITYTYPE ST_I18N_PA ".ActivityType"
#define ST_KEY_PA_ACTIVITYTYPE ST_KEY_PA ".ActivityType"
#define ST_I18N_PA_AQ ST_I18N_PA ".AQ"
#define ST_KEY_PA_AQ ST_KEY_PA ".AQ"
#define ST_I18N_PA_AQ_PERCEPTUAL ST_I18N_PA_AQ ".Perceptual"
#define ST_KEY_PA_AQ_PERCEPTUAL ST_KEY_PA_AQ ".Perceptual"
#define ST_I18N_PA_AQ_CONTENT ST_I18N_PA_AQ ".Content"
#define ST_KEY_PA_AQ_CONTENT ST_KEY_PA_AQ ".Content"
#define ST_I18N_PA_AQ_TEMPORAL ST_I18N_PA_AQ ".Temporal"
#define ST_KEY_PA_AQ_TEMPORAL ST_KEY_PA_AQ ".Temporal"
#define ST_I18N_PA_HIGHMOTIONQUALITYBOOST ST_I18N_PA ".HighMotionQualityBoost"
#define ST_KEY_PA_HIGHMOTIONQUALITYBOOST ST_KEY_PA ".HighMotionQualityBoost"
#define ST_I18N_PA_ADAPTIVEMINIGOP ST_I18N_PA ".AdaptiveMiniGOP"
#define ST_KEY_PA_ADAPTIVEMINIGOP ST_KEY_PA ".AdaptiveMiniGOP"
#define ST_I18N_PA_FRAME_SAD ST_I18N_PA ".FrameSAD"
#define ST_KEY_PA_FRAME_SAD ST_KEY_PA ".FrameSAD"
#define ST_I18N_PA_LTR ST_I18N_PA ".LTR"
#define ST_KEY_PA_LTR ST_KEY_PA ".LTR"

#define ST_I18N_OTHER ST_I18N ".Other"
#define ST_KEY_OTHER "Other"
#define ST_I18N_OTHER_BFRAMES ST_I18N_OTHER ".BFrames"
#define ST_KEY_OTHER_BFRAMES ST_KEY_OTHER ".BFrames"
#define ST_I18N_OTHER_BFRAMEREFERENCES ST_I18N_OTHER ".BFrameReferences"
#define ST_KEY_OTHER_BFRAMEREFERENCES ST_KEY_OTHER ".BFrameReferences"
#define ST_I18N_OTHER_VBAQ ST_I18N_OTHER ".VBAQ"
#define ST_KEY_OTHER_VBAQ ST_KEY_OTHER ".VBAQ"
#define ST_I18N_OTHER_HIGHMOTIONQUALITYBOOST ST_I18N_OTHER ".HighMotionQualityBoost"
#define ST_KEY_OTHER_HIGHMOTIONQUALITYBOOST ST_KEY_OTHER ".HighMotionQualityBoost"
#define ST_I18N_OTHER_REFERENCEFRAMES ST_I18N_OTHER ".ReferenceFrames"
#define ST_KEY_OTHER_REFERENCEFRAMES ST_KEY_OTHER ".ReferenceFrames"

#define ST_KEY_H264_PROFILE "H264.Profile"
#define ST_KEY_H264_LEVEL "H264.Level"

#define ST_KEY_H265_PROFILE "H265.Profile"
#define ST_KEY_H265_TIER "H265.Tier"
#define ST_KEY_H265_LEVEL "H265.Level"

#define ST_KEY_AV1_PROFILE "AV1.Profile"
#define ST_KEY_AV1_LEVEL "AV1.Level"

#define TEST_AVERROR(x)                                                           \
	if (int ret = x; ret != 0) {                                                  \
		DLOG_ERROR("%s: %s (%" PRId32 ")", D_VSTR(x), get_error_description(ret), ret); \
	}

using namespace streamfx::encoder::ffmpeg;
using namespace streamfx::encoder::codec;
using namespace streamfx::ffmpeg::tools;

bool amf::is_available()
{
#if defined(D_PLATFORM_WINDOWS)
#if defined(D_PLATFORM_64BIT)
	std::filesystem::path lib_name = "amfrt64.dll";
#else
	std::filesystem::path lib_name = "amfrt32.dll";
#endif
#else
#if defined(D_PLATFORM_64BIT)
	std::filesystem::path lib_name = "libamfrt64.so.1";
#else
	std::filesystem::path lib_name = "libamfrt32.so.1";
#endif
#endif
	try {
		streamfx::util::library::load(lib_name);
		return true;
	} catch (...) {
		return false;
	}
}

void amf::defaults(ffmpeg_factory* factory, obs_data_t* settings)
{
	obs_data_set_default_string(settings, ST_KEY_QUALITY, "balanced");
	obs_data_set_default_string(settings, ST_KEY_USAGE, "transcoding");

	obs_data_set_default_string(settings, ST_KEY_RATECONTROL_MODE, "cbr");
	obs_data_set_default_int(settings, ST_KEY_RATECONTROL_PREENCODE, -1);
	obs_data_set_default_int(settings, ST_KEY_RATECONTROL_LIMITS_BITRATE_TARGET, 6000);
	obs_data_set_default_int(settings, ST_KEY_RATECONTROL_LIMITS_BITRATE_MAXIMUM, 0);
	obs_data_set_default_int(settings, ST_KEY_RATECONTROL_LIMITS_BUFFERSIZE, 0);
	obs_data_set_default_int(settings, ST_KEY_RATECONTROL_LIMITS_QUALITY, -1);
	obs_data_set_default_int(settings, ST_KEY_RATECONTROL_QP_I, -1);
	obs_data_set_default_int(settings, ST_KEY_RATECONTROL_QP_P, -1);
	obs_data_set_default_int(settings, ST_KEY_RATECONTROL_QP_B, -1);

	obs_data_set_default_int(settings, ST_KEY_PA, -1);
	obs_data_set_default_int(settings, ST_KEY_PA_LOOKAHEAD, -1);
	obs_data_set_default_string(settings, ST_KEY_PA_SCENECHANGEDETECTION, "default");
	obs_data_set_default_string(settings, ST_KEY_PA_STATICSCENEDETECTION, "default");
	obs_data_set_default_string(settings, ST_KEY_PA_ACTIVITYTYPE, "default");
	obs_data_set_default_string(settings, ST_KEY_PA_AQ_PERCEPTUAL, "default");
	obs_data_set_default_string(settings, ST_KEY_PA_AQ_CONTENT, "default");
	obs_data_set_default_string(settings, ST_KEY_PA_AQ_TEMPORAL, "default");
	obs_data_set_default_string(settings, ST_KEY_PA_HIGHMOTIONQUALITYBOOST, "default");
	obs_data_set_default_int(settings, ST_KEY_PA_ADAPTIVEMINIGOP, -1);
	obs_data_set_default_int(settings, ST_KEY_PA_FRAME_SAD, -1);
	obs_data_set_default_int(settings, ST_KEY_PA_LTR, -1);

	obs_data_set_default_int(settings, ST_KEY_OTHER_BFRAMES, -1);
	obs_data_set_default_int(settings, ST_KEY_OTHER_BFRAMEREFERENCES, -1);
	obs_data_set_default_int(settings, ST_KEY_OTHER_VBAQ, -1);
	obs_data_set_default_int(settings, ST_KEY_OTHER_HIGHMOTIONQUALITYBOOST, -1);
	obs_data_set_default_int(settings, ST_KEY_OTHER_REFERENCEFRAMES, -1);

	// Dynamic Bitrate and Replay Buffer
	obs_data_set_default_int(settings, "bitrate", -1);
	obs_data_unset_user_value(settings, "bitrate");
}

static bool is_cbr(const char* value)
{
	return (strcmp("cbr", value) == 0) || (strcmp("hqcbr", value) == 0);
}

static bool is_vbr(const char* value)
{
	return (strcmp("vbr", value) == 0) || (strcmp("hqvbr", value) == 0) || (strcmp("vbr_peak", value) == 0) || (strcmp("vbr_latency", value) == 0);
}

static bool is_cq(const char* value)
{
	return (strcmp("qvbr", value) == 0);
}

static bool is_quality(const char* value)
{
	return (strcmp("hqvbr", value) == 0) || (strcmp("hqcbr", value) == 0) || (strcmp("qvbr", value) == 0);
}

static bool is_cqp(const char* value)
{
	return (strcmp("cqp", value) == 0);
}

static void have_flags(const char* value, bool& bitrate, bool& bitrate_range, bool& quality, bool& qp_limits, bool& qp)
{
	bitrate       = false;
	bitrate_range = false;
	quality       = false;
	qp_limits     = false;
	qp            = false;
	if (is_cbr(value)) {
		bitrate = true;
	} else if (is_vbr(value)) {
		bitrate       = true;
		bitrate_range = true;
		qp_limits     = true;
		qp            = true;
	} else if (is_cq(value)) {
		bitrate       = true;
		bitrate_range = true;
		quality       = true;
		qp_limits     = true;
		qp            = true;
	} else if (is_cqp(value)) {
		qp = true;
	} else {
		bitrate       = true;
		bitrate_range = true;
		quality       = true;
		qp_limits     = true;
		qp            = true;
	}
}

static bool modified_pa(obs_properties_t* props, obs_property_t*, obs_data_t* settings) noexcept
{
	const char* rc_mode  = obs_data_get_string(settings, ST_KEY_RATECONTROL_MODE);
	bool        is_pa_on = (is_quality(rc_mode) || (obs_data_get_int(settings, ST_KEY_PA) != 0)) && !is_cqp(rc_mode);

	// Doesn't have VBAQ, hide the entire block if needed.
	obs_property_set_visible(obs_properties_get(props, ST_I18N_PA_AQ), is_pa_on);

	return true;
}

static bool modified_ratecontrol(obs_properties_t* props, obs_property_t* prop, obs_data_t* settings) noexcept
{
	// Decode the name into useful flags.
	const char* value              = obs_data_get_string(settings, ST_KEY_RATECONTROL_MODE);
	bool        have_bitrate       = false;
	bool        have_bitrate_range = false;
	bool        have_quality       = false;
	bool        _unused            = false;
	bool        have_qp            = false;
	have_flags(value, have_bitrate, have_bitrate_range, have_quality, _unused, have_qp);

	obs_property_set_visible(obs_properties_get(props, ST_I18N_RATECONTROL_LIMITS), have_bitrate || have_quality);
	obs_property_set_visible(obs_properties_get(props, ST_KEY_RATECONTROL_LIMITS_BUFFERSIZE), have_bitrate);
	obs_property_set_visible(obs_properties_get(props, ST_KEY_RATECONTROL_LIMITS_QUALITY), have_quality);
	obs_property_set_visible(obs_properties_get(props, ST_KEY_RATECONTROL_LIMITS_BITRATE_TARGET), have_bitrate);
	obs_property_set_visible(obs_properties_get(props, ST_KEY_RATECONTROL_LIMITS_BITRATE_MAXIMUM), have_bitrate_range);

	obs_property_set_visible(obs_properties_get(props, ST_I18N_RATECONTROL_QP), have_qp);
	obs_property_set_visible(obs_properties_get(props, ST_KEY_RATECONTROL_QP_I), have_qp);
	obs_property_set_visible(obs_properties_get(props, ST_KEY_RATECONTROL_QP_P), have_qp);
	obs_property_set_visible(obs_properties_get(props, ST_KEY_RATECONTROL_QP_B), have_qp);

	// Update Pre-Analysis
	obs_property_set_visible(obs_properties_get(props, ST_I18N_PA), !is_cqp(value));
	modified_pa(props, prop, settings);

	// Update Other Options
	obs_property_set_visible(obs_properties_get(props, ST_KEY_OTHER_VBAQ), !is_cqp(value));
	obs_property_set_visible(obs_properties_get(props, ST_KEY_OTHER_HIGHMOTIONQUALITYBOOST), !is_cqp(value));

	return true;
}

static bool modified_pa_aq_perceptual(obs_properties_t* props, obs_property_t*, obs_data_t* settings) noexcept
{
	const char* paq_mode = obs_data_get_string(settings, ST_KEY_PA_AQ_PERCEPTUAL);
	obs_property_set_visible(obs_properties_get(props, ST_KEY_PA_AQ_CONTENT), std::string_view{"caq"} == paq_mode);

	return true;
}

void amf::properties_before(ffmpeg_factory* factory, ffmpeg_instance* instance, obs_properties_t* props, AVCodecContext* context)
{
	auto codec = factory->get_avcodec();

	{ // Quality, but not the one from FFmpeg.
		// We ignore the FFmpeg one here, since AMD is - as usual - inconsistent and not backwards compatible.
		auto p = obs_properties_add_list(props, ST_KEY_QUALITY, D_TRANSLATE(ST_I18N_QUALITY), OBS_COMBO_TYPE_LIST, OBS_COMBO_FORMAT_STRING);
		/* streamfx::ffmpeg::tools::avoption_list_add_entries(context->priv_data, "quality", [&p](const AVOption* opt) {
			char buffer[1024];
			snprintf(buffer, sizeof(buffer), "%s.%s", ST_I18N_QUALITY, opt->name);
			obs_property_list_add_string(p, D_TRANSLATE_DEFAULT(buffer, opt->name), opt->name);
		});*/
		for (auto key : {"speed", "balanced", "quality", "high_quality"}) {
			char buffer[1024];
			snprintf(buffer, sizeof(buffer), "%s.%s", ST_I18N_QUALITY, key);
			obs_property_list_add_string(p, D_TRANSLATE_DEFAULT(buffer, key), key);
		}
	}

	{ // Usage, but again not from FFmpeg.
		// We ignore the FFmpeg one here, since AMD is - as usual - inconsistent and not backwards compatible.
		auto p = obs_properties_add_list(props, ST_KEY_USAGE, D_TRANSLATE(ST_I18N_USAGE), OBS_COMBO_TYPE_LIST, OBS_COMBO_FORMAT_STRING);
		/* streamfx::ffmpeg::tools::avoption_list_add_entries(context->priv_data, "usage", [&p](const AVOption* opt) {
			char buffer[1024];
			snprintf(buffer, sizeof(buffer), "%s.%s", ST_I18N_USAGE, opt->name);
			obs_property_list_add_string(p, D_TRANSLATE_DEFAULT(buffer, opt->name), opt->name);
		});*/
		for (auto key : {"transcoding", "lowlatency"}) {
			char buffer[1024];
			snprintf(buffer, sizeof(buffer), "%s.%s", ST_I18N_USAGE, key);
			obs_property_list_add_string(p, D_TRANSLATE_DEFAULT(buffer, key), key);
		}
	}
}

void amf::properties_after(ffmpeg_factory* factory, ffmpeg_instance* instance, obs_properties_t* props, AVCodecContext* context)
{
	auto codec = factory->get_avcodec();

	{ // Rate Control
		obs_properties_t* grp = obs_properties_create();
		obs_properties_add_group(props, ST_I18N_RATECONTROL, D_TRANSLATE(ST_I18N_RATECONTROL), OBS_GROUP_NORMAL, grp);

		{ // Mode
			auto p = obs_properties_add_list(grp, ST_KEY_RATECONTROL_MODE, D_TRANSLATE(ST_I18N_RATECONTROL_MODE), OBS_COMBO_TYPE_LIST, OBS_COMBO_FORMAT_STRING);
			obs_property_set_modified_callback(p, modified_ratecontrol);
			obs_property_list_add_string(p, D_TRANSLATE(S_STATE_DEFAULT), "");
			streamfx::ffmpeg::tools::avoption_list_add_entries(context->priv_data, "rc", [&p](const AVOption* opt) {
				char buffer[1024];
				snprintf(buffer, sizeof(buffer), "%s.%s", ST_I18N_RATECONTROL_MODE, opt->name);
				obs_property_list_add_string(p, D_TRANSLATE_DEFAULT(buffer, opt->help ? opt->help : opt->name), opt->name);
			});
		}

		if (avoption_exists(context->priv_data, "preencode")) { // Pre-Encode
			auto p = streamfx::util::obs_properties_add_tristate(grp, ST_KEY_RATECONTROL_PREENCODE, D_TRANSLATE(ST_I18N_RATECONTROL_PREENCODE));
		}

		{ // Limits
			obs_properties_t* grp2 = obs_properties_create();
			obs_properties_add_group(grp, ST_I18N_RATECONTROL_LIMITS, D_TRANSLATE(ST_I18N_RATECONTROL_LIMITS), OBS_GROUP_NORMAL, grp2);

			if (avoption_exists(context->priv_data, "qvbr_quality_level")) { // Quality
				auto p = obs_properties_add_int_slider(grp2, ST_KEY_RATECONTROL_LIMITS_QUALITY, D_TRANSLATE(ST_I18N_RATECONTROL_LIMITS_QUALITY), -1, 51, 1);
			}

			{ // Bitrate Target
				auto p = obs_properties_add_int(grp2, ST_KEY_RATECONTROL_LIMITS_BITRATE_TARGET, D_TRANSLATE(ST_I18N_RATECONTROL_LIMITS_BITRATE_TARGET), -1, std::numeric_limits<int32_t>::max(), 1);
				obs_property_int_set_suffix(p, " kbit/s");
			}

			{ // Bitrate Maximum
				auto p = obs_properties_add_int(grp2, ST_KEY_RATECONTROL_LIMITS_BITRATE_MAXIMUM, D_TRANSLATE(ST_I18N_RATECONTROL_LIMITS_BITRATE_MAXIMUM), -1, std::numeric_limits<int32_t>::max(), 1);
				obs_property_int_set_suffix(p, " kbit/s");
			}

			{ // Buffer Size
				auto p = obs_properties_add_int(grp2, ST_KEY_RATECONTROL_LIMITS_BUFFERSIZE, D_TRANSLATE(ST_I18N_RATECONTROL_LIMITS_BUFFERSIZE), 0, std::numeric_limits<int32_t>::max(), 1);
				obs_property_int_set_suffix(p, " kbit");
			}
		}

		{ // QP
			obs_properties_t* grp2 = obs_properties_create();
			obs_properties_add_group(grp, ST_I18N_RATECONTROL_QP, D_TRANSLATE(ST_I18N_RATECONTROL_QP), OBS_GROUP_NORMAL, grp2);

			if (avoption_exists(context->priv_data, "qp_i")) {
				auto p = obs_properties_add_int_slider(grp2, ST_KEY_RATECONTROL_QP_I, D_TRANSLATE(ST_I18N_RATECONTROL_QP_I), -1, 51, 1);
			}
			if (avoption_exists(context->priv_data, "qp_p")) {
				auto p = obs_properties_add_int_slider(grp2, ST_KEY_RATECONTROL_QP_P, D_TRANSLATE(ST_I18N_RATECONTROL_QP_P), -1, 51, 1);
			}
			if (avoption_exists(context->priv_data, "qp_b")) {
				auto p = obs_properties_add_int_slider(grp2, ST_KEY_RATECONTROL_QP_B, D_TRANSLATE(ST_I18N_RATECONTROL_QP_B), -1, 51, 1);
			}
		}
	}

	if (avoption_exists(context->priv_data, "preanalysis")) { // Pre-Analysis
		obs_properties_t* grp = obs_properties_create();
		obs_properties_add_group(props, ST_I18N_PA, D_TRANSLATE(ST_I18N_PA), OBS_GROUP_NORMAL, grp);

		{ // Pre-Analysis
			auto p = streamfx::util::obs_properties_add_tristate(grp, ST_KEY_PA, D_TRANSLATE(ST_I18N_PA));
			obs_property_set_modified_callback(p, modified_pa);
		}

		if (avoption_exists(context->priv_data, "pa_lookahead_buffer_depth")) { // Look-Ahead
			auto p = obs_properties_add_int_slider(grp, ST_KEY_PA_LOOKAHEAD, D_TRANSLATE(ST_I18N_PA_LOOKAHEAD), -1, 41, 1);
			obs_property_int_set_suffix(p, " frames");
		}

		if (avoption_exists(context->priv_data, "pa_scene_change_detection_enable")) { // Scene Change Detection
			auto p = obs_properties_add_list(grp, ST_KEY_PA_SCENECHANGEDETECTION, D_TRANSLATE(ST_I18N_PA_SCENECHANGEDETECTION), OBS_COMBO_TYPE_LIST, OBS_COMBO_FORMAT_STRING);
			obs_property_list_add_string(p, D_TRANSLATE(S_STATE_DEFAULT), "default");
			obs_property_list_add_string(p, D_TRANSLATE(S_STATE_DISABLED), "disabled");
			streamfx::ffmpeg::tools::avoption_list_add_entries(context->priv_data, "pa_scene_change_detection_sensitivity", [&p](const AVOption* opt) {
				char buffer[1024];
				snprintf(buffer, sizeof(buffer), "%s.%s", ST_I18N_PA_SCENECHANGEDETECTION, opt->name);
				obs_property_list_add_string(p, D_TRANSLATE_DEFAULT(buffer, opt->help ? opt->help : opt->name), opt->name);
			});
		}

		if (avoption_exists(context->priv_data, "pa_static_scene_detection_enable")) { // Static Scene Detection
			auto p = obs_properties_add_list(grp, ST_KEY_PA_STATICSCENEDETECTION, D_TRANSLATE(ST_I18N_PA_STATICSCENEDETECTION), OBS_COMBO_TYPE_LIST, OBS_COMBO_FORMAT_STRING);
			obs_property_list_add_string(p, D_TRANSLATE(S_STATE_DEFAULT), "default");
			obs_property_list_add_string(p, D_TRANSLATE(S_STATE_DISABLED), "disabled");
			streamfx::ffmpeg::tools::avoption_list_add_entries(context->priv_data, "pa_static_scene_detection_sensitivity", [&p](const AVOption* opt) {
				char buffer[1024];
				snprintf(buffer, sizeof(buffer), "%s.%s", ST_I18N_PA_STATICSCENEDETECTION, opt->name);
				obs_property_list_add_string(p, D_TRANSLATE_DEFAULT(buffer, opt->help ? opt->help : opt->name), opt->name);
			});
		}

		if (avoption_exists(context->priv_data, "pa_paq_mode") || avoption_exists(context->priv_data, "pa_taq_mode")) { // Adaptive Quantization
			obs_properties_t* grp2 = obs_properties_create();
			obs_properties_add_group(grp, ST_I18N_PA_AQ, D_TRANSLATE(ST_I18N_PA_AQ), OBS_GROUP_NORMAL, grp2);

			if (avoption_exists(context->priv_data, "pa_paq_mode")) { // Perceptual Adaptive Quantization
				auto p = obs_properties_add_list(grp2, ST_KEY_PA_AQ_PERCEPTUAL, D_TRANSLATE(ST_I18N_PA_AQ_PERCEPTUAL), OBS_COMBO_TYPE_LIST, OBS_COMBO_FORMAT_STRING);
				obs_property_set_modified_callback(p, modified_pa_aq_perceptual);
				obs_property_list_add_string(p, D_TRANSLATE(S_STATE_DEFAULT), "default");
				streamfx::ffmpeg::tools::avoption_list_add_entries(context->priv_data, "pa_paq_mode", [&p](const AVOption* opt) {
					char buffer[1024];
					snprintf(buffer, sizeof(buffer), "%s.%s", ST_I18N_PA_AQ_PERCEPTUAL, opt->name);
					obs_property_list_add_string(p, D_TRANSLATE_DEFAULT(buffer, opt->help ? opt->help : opt->name), opt->name);
				});

				if (avoption_exists(context->priv_data, "pa_caq_strength")) { // Content Adaptive Quantization Strength
					auto p = obs_properties_add_list(grp2, ST_KEY_PA_AQ_CONTENT, D_TRANSLATE(ST_I18N_PA_AQ_CONTENT), OBS_COMBO_TYPE_LIST, OBS_COMBO_FORMAT_STRING);
					obs_property_list_add_string(p, D_TRANSLATE(S_STATE_DEFAULT), "default");
					streamfx::ffmpeg::tools::avoption_list_add_entries(context->priv_data, "pa_caq_strength", [&p](const AVOption* opt) {
						char buffer[1024];
						snprintf(buffer, sizeof(buffer), "%s.%s", ST_I18N_PA_SCENECHANGEDETECTION, opt->name);
						obs_property_list_add_string(p, D_TRANSLATE_DEFAULT(buffer, opt->help ? opt->help : opt->name), opt->name);
					});
				}
			}

			if (avoption_exists(context->priv_data, "pa_taq_mode")) { // Temporal Adaptive Quantization
				auto p = obs_properties_add_list(grp2, ST_KEY_PA_AQ_TEMPORAL, D_TRANSLATE(ST_I18N_PA_AQ_TEMPORAL), OBS_COMBO_TYPE_LIST, OBS_COMBO_FORMAT_STRING);
				obs_property_list_add_string(p, D_TRANSLATE(S_STATE_DEFAULT), "default");
				streamfx::ffmpeg::tools::avoption_list_add_entries(context->priv_data, "pa_taq_mode", [&p](const AVOption* opt) {
					char buffer[1024];
					snprintf(buffer, sizeof(buffer), "%s.%s", ST_I18N_PA_AQ_TEMPORAL, opt->name);
					obs_property_list_add_string(p, D_TRANSLATE_DEFAULT(buffer, opt->help ? opt->help : opt->name), opt->name);
				});
			}
		}

		if (avoption_exists(context->priv_data, "pa_high_motion_quality_boost_mode")) { // High Motion Quality Boost
			auto p = obs_properties_add_list(grp, ST_KEY_PA_HIGHMOTIONQUALITYBOOST, D_TRANSLATE(ST_I18N_PA_HIGHMOTIONQUALITYBOOST), OBS_COMBO_TYPE_LIST, OBS_COMBO_FORMAT_STRING);
			obs_property_list_add_string(p, D_TRANSLATE(S_STATE_DEFAULT), "default");
			streamfx::ffmpeg::tools::avoption_list_add_entries(context->priv_data, "pa_high_motion_quality_boost_mode", [&p](const AVOption* opt) {
				char buffer[1024];
				snprintf(buffer, sizeof(buffer), "%s.%s", ST_I18N_PA_HIGHMOTIONQUALITYBOOST, opt->name);
				obs_property_list_add_string(p, D_TRANSLATE_DEFAULT(buffer, opt->help ? opt->help : opt->name), opt->name);
			});
		}
	}

	{ // Other Options
		obs_properties_t* grp = obs_properties_create();
		obs_properties_add_group(props, ST_I18N_OTHER, D_TRANSLATE(ST_I18N_OTHER), OBS_GROUP_NORMAL, grp);

		// B-Frames
		if (std::string_view{"h264_amf"} == codec->name) { // Only H264
			{
				auto p = obs_properties_add_int_slider(grp, ST_KEY_OTHER_BFRAMES, D_TRANSLATE(ST_I18N_OTHER_BFRAMES), -1, 3, 1);
			}

			{
				auto p = streamfx::util::obs_properties_add_tristate(grp, ST_KEY_OTHER_BFRAMEREFERENCES, D_TRANSLATE(ST_I18N_OTHER_BFRAMEREFERENCES));
			}
		}

		// Variance Based Adaptive Quantization
		if (avoption_exists(context->priv_data, "vbaq")) { // Not AV1
			{
				auto p = streamfx::util::obs_properties_add_tristate(grp, ST_KEY_OTHER_VBAQ, D_TRANSLATE(ST_I18N_OTHER_VBAQ));
			}
		}

		// High Motion Quality Boost
		if (avoption_exists(context->priv_data, "high_motion_quality_boost_enable")) {
			auto p = streamfx::util::obs_properties_add_tristate(grp, ST_KEY_OTHER_HIGHMOTIONQUALITYBOOST, D_TRANSLATE(ST_I18N_OTHER_HIGHMOTIONQUALITYBOOST));
		}

		// Maximum Reference Frames (16 for non-AV1, 8 for AV1)
		if (std::string_view{"av1_amf"} != codec->name) { // Not AV1
			auto p = obs_properties_add_int_slider(grp, ST_KEY_OTHER_REFERENCEFRAMES, D_TRANSLATE(ST_I18N_OTHER_REFERENCEFRAMES), -1, 16, 1);
		} else {
			auto p = obs_properties_add_int_slider(grp, ST_KEY_OTHER_REFERENCEFRAMES, D_TRANSLATE(ST_I18N_OTHER_REFERENCEFRAMES), -1, 8, 1);
		}
	}
}

void amf::migrate(ffmpeg_factory* factory, ffmpeg_instance* instance, obs_data_t* settings, uint64_t version) {}

void amf::update(ffmpeg_factory* factory, ffmpeg_instance* instance, obs_data_t* settings)
{
	auto codec   = factory->get_avcodec();
	auto context = instance->get_avcodeccontext();

	auto quality = obs_data_get_string(settings, ST_KEY_QUALITY);
	auto usage   = obs_data_get_string(settings, ST_KEY_USAGE);
	auto rc      = obs_data_get_string(settings, ST_KEY_RATECONTROL_MODE);

	if (!context->internal) { // Pre-initialization only
		// Usage, Quality
		// Need to jump through some hoops to get something useful out of AMD's AMF.
		if ((strcmp("high_quality", quality) == 0) && (strcmp("av1_amf", codec->name) != 0)) {
			if (strcmp("transcoding", usage) == 0) {
				TEST_AVERROR(av_opt_set(context, "usage", "high_quality", AV_OPT_SEARCH_CHILDREN));
				TEST_AVERROR(av_opt_set(context, "quality", "quality", AV_OPT_SEARCH_CHILDREN));
			} else if (strcmp("lowlatency", usage) == 0) {
				TEST_AVERROR(av_opt_set(context, "usage", "lowlatency_high_quality", AV_OPT_SEARCH_CHILDREN));
				TEST_AVERROR(av_opt_set(context, "quality", "quality", AV_OPT_SEARCH_CHILDREN));
			} else {
				TEST_AVERROR(av_opt_set(context, "usage", usage, AV_OPT_SEARCH_CHILDREN));
				TEST_AVERROR(av_opt_set(context, "quality", quality, AV_OPT_SEARCH_CHILDREN));
			}
		} else {
			TEST_AVERROR(av_opt_set(context, "usage", usage, AV_OPT_SEARCH_CHILDREN));
			TEST_AVERROR(av_opt_set(context, "quality", quality, AV_OPT_SEARCH_CHILDREN));
		}
	}

	{ // Rate Control
		if (context->internal) {
			// ToDo: Retrieve current rate control setting from FFmpeg.
		}

		bool have_bitrate       = false;
		bool have_bitrate_range = false;
		bool have_quality       = false;
		bool _unused            = false;
		bool have_qp            = false;
		have_flags(rc, have_bitrate, have_bitrate_range, have_quality, _unused, have_qp);

		if (!context->internal) { // Pre-initialization only, though AMD does support switching this on the go.
			// Rate Control Mode
			TEST_AVERROR(av_opt_set(context, "rc", rc, AV_OPT_SEARCH_CHILDREN));

			// Filler Data setting, required for CBR only.
			TEST_AVERROR(av_opt_set_int(context, "filler_data", is_cbr(rc) ? 1 : 0, AV_OPT_SEARCH_CHILDREN));

			// Pre-Encode
			if (auto v = obs_data_get_int(settings, ST_KEY_RATECONTROL_PREENCODE); v != -1)
				TEST_AVERROR(av_opt_set_int(context, "preencode", v, AV_OPT_SEARCH_CHILDREN));
		}

		if (have_bitrate) {
			// Target Bitrate
			int64_t v = obs_data_get_int(settings, ST_KEY_RATECONTROL_LIMITS_BITRATE_TARGET);

			// Allow OBS to specify a maximum allowed bitrate, as well as a dynamically adjusted bitrate.
			if (auto v2 = obs_data_get_int(settings, "bitrate"); (v2 != -1) && (v2 != v)) {
				v = std::clamp<int64_t>(v, -1, v2);
			}

			if (v > -1) {
				context->bit_rate = static_cast<int>(v * 1000);
			}
		}

		if (have_bitrate_range) {
			// Maximum Bitrate
			if (int64_t max = obs_data_get_int(settings, ST_KEY_RATECONTROL_LIMITS_BITRATE_MAXIMUM); max > -1) {
				context->rc_max_rate = static_cast<int>(max * 1000);
			} else {
				context->rc_max_rate = context->bit_rate;
			}

			// Allow OBS to specify a maximum allowed bitrate, as well as a dynamically adjusted bitrate.
			if (auto v2 = obs_data_get_int(settings, "bitrate"); (v2 != -1) && (v2 != context->rc_max_rate)) {
				context->rc_max_rate = std::clamp<int64_t>(context->rc_max_rate, -1, v2);
			}

			context->rc_min_rate = context->bit_rate;
		} else {
			context->rc_min_rate = context->bit_rate;
			context->rc_max_rate = context->bit_rate;
		}

		// Buffer Size
		if (have_bitrate || have_bitrate_range) {
			if (int64_t v = obs_data_get_int(settings, ST_KEY_RATECONTROL_LIMITS_BUFFERSIZE); v > 0) {
				context->rc_buffer_size = static_cast<int>(v * 1000);
			} else {
				context->rc_buffer_size = context->bit_rate * 2;
			}
		} else {
			context->rc_buffer_size = 0;
		}

		if (!context->internal) { // Pre-initialization only
			// Quality Limits
			context->qmin = -1;
			context->qmax = -1;

			// Quality Target
			if (have_quality && (avoption_exists(context->priv_data, "qvbr_quality_level"))) {
				TEST_AVERROR(av_opt_set_int(context->priv_data, "qvbr_quality_level", obs_data_get_int(settings, ST_KEY_RATECONTROL_LIMITS_QUALITY), AV_OPT_SEARCH_CHILDREN));
			}

			// QP Settings
			if (have_qp) {
				if (int64_t qp = obs_data_get_int(settings, ST_KEY_RATECONTROL_QP_I); avoption_exists(context->priv_data, "qp_i") && qp > -1)
					av_opt_set_int(context->priv_data, "qp_i", static_cast<int>(qp), AV_OPT_SEARCH_CHILDREN);
				if (int64_t qp = obs_data_get_int(settings, ST_KEY_RATECONTROL_QP_P); avoption_exists(context->priv_data, "qp_p") && qp > -1)
					av_opt_set_int(context->priv_data, "qp_p", static_cast<int>(qp), AV_OPT_SEARCH_CHILDREN);
				if (int64_t qp = obs_data_get_int(settings, ST_KEY_RATECONTROL_QP_B); avoption_exists(context->priv_data, "qp_b") && qp > -1)
					av_opt_set_int(context->priv_data, "qp_b", static_cast<int>(qp), AV_OPT_SEARCH_CHILDREN);
			}
		}

		if (!context->internal) { // Pre-initialization only
			// "Enforce HRD", which is required for bitrate and buffer control.
			TEST_AVERROR(av_opt_set_int(context, "enforce_hrd", (have_bitrate || have_bitrate_range) ? 1 : 0, AV_OPT_SEARCH_CHILDREN));

			// Replay Buffer and Dynamic Bitrate
			if (have_bitrate) {
				obs_data_set_int(settings, "bitrate", context->rc_max_rate);
			}
		}
	}

	if (!context->internal) { // Pre-initialization only
		if (avoption_exists(context->priv_data, "preanalysis")) { // Pre-Analysis
			// - Required by qvbr, hqvbr and hqcbr.
			auto pav = obs_data_get_int(settings, ST_KEY_PA);
			if (is_quality(rc)) {
				pav = 1;
			} else if (is_cqp(rc)) {
				pav = 0;
			}

			if (pav != -1) {
				TEST_AVERROR(av_opt_set_int(context, "preanalysis", pav, AV_OPT_SEARCH_CHILDREN));
			}

			if (pav != 0) {
				// Look-Ahead
				if (auto v = obs_data_get_int(settings, ST_KEY_PA_LOOKAHEAD); v != -1)
					TEST_AVERROR(av_opt_set_int(context, "pa_lookahead_buffer_depth", v, AV_OPT_SEARCH_CHILDREN));

				// Activity Type
				if (auto v = obs_data_get_string(settings, ST_KEY_PA_ACTIVITYTYPE); true)
					TEST_AVERROR(av_opt_set(context, "pa_activity_type", v, AV_OPT_SEARCH_CHILDREN));

				// Scene Change Detection
				if (auto v = obs_data_get_string(settings, ST_KEY_PA_SCENECHANGEDETECTION); std::string_view{"default"} != v) {
					if (std::string_view{"disabled"} == v) {
						TEST_AVERROR(av_opt_set(context, "pa_scene_change_detection_enable", "false", AV_OPT_SEARCH_CHILDREN));
					} else {
						TEST_AVERROR(av_opt_set(context, "pa_scene_change_detection_enable", "true", AV_OPT_SEARCH_CHILDREN));
						TEST_AVERROR(av_opt_set(context, "pa_scene_change_detection_sensitivity", v, AV_OPT_SEARCH_CHILDREN));
					}
				}

				// Static Scene Detection
				if (auto v = obs_data_get_string(settings, ST_KEY_PA_STATICSCENEDETECTION); std::string_view{"default"} != v) {
					if (std::string_view{"disabled"} == v) {
						TEST_AVERROR(av_opt_set(context, "pa_static_scene_detection_enable", "false", AV_OPT_SEARCH_CHILDREN));
					} else {
						TEST_AVERROR(av_opt_set(context, "pa_static_scene_detection_enable", "true", AV_OPT_SEARCH_CHILDREN));
						TEST_AVERROR(av_opt_set(context, "pa_static_scene_detection_sensitivity", v, AV_OPT_SEARCH_CHILDREN));
					}
				}

				// Adaptive Quantization
				{
					// Perceptual Adaptive Quantization
					if (auto v = obs_data_get_string(settings, ST_KEY_PA_AQ_PERCEPTUAL); std::string_view{"default"} != v) {
						TEST_AVERROR(av_opt_set(context, "pa_paq_mode", v, AV_OPT_SEARCH_CHILDREN));
						if (std::string_view{"caq"} == v) {
							// Content Adaptive Quantization Strength
							if (auto v2 = obs_data_get_string(settings, ST_KEY_PA_AQ_CONTENT); std::string_view{"default"} != v2) {
								TEST_AVERROR(av_opt_set(context, "pa_caq_strength", v2, AV_OPT_SEARCH_CHILDREN));
							}
						}
					}

					// Temporal Adaptive Quantization
					if (auto v = obs_data_get_string(settings, ST_KEY_PA_AQ_TEMPORAL); std::string_view{"default"} != v) {
						TEST_AVERROR(av_opt_set(context, "pa_taq_mode", v, AV_OPT_SEARCH_CHILDREN));
					}
				}

				// High Motion Quality Boost
				if (auto v = obs_data_get_string(settings, ST_KEY_PA_HIGHMOTIONQUALITYBOOST); v) {
					TEST_AVERROR(av_opt_set(context, "pa_high_motion_quality_boost_mode", v, AV_OPT_SEARCH_CHILDREN));
				}

				// Adaptive Mini-GOP (H264 only)
				if (std::string_view{"h264_amf"} == codec->name) {
					if (auto v = obs_data_get_int(settings, ST_KEY_PA_ADAPTIVEMINIGOP); v != -1) {
						TEST_AVERROR(av_opt_set_int(context, "pa_adaptive_mini_gop", v, AV_OPT_SEARCH_CHILDREN));
					} else {
						// AMD suggests turning this on if B-Frames are > 0
						if (obs_data_get_int(settings, ST_KEY_OTHER_BFRAMES) != 0) {
							TEST_AVERROR(av_opt_set_int(context, "pa_adaptive_mini_gop", 1, AV_OPT_SEARCH_CHILDREN));
						}
					}
				}

				// Frame SAD
				if (auto v = obs_data_get_int(settings, ST_KEY_PA_FRAME_SAD); v != -1) {
					TEST_AVERROR(av_opt_set_int(context, "pa_frame_sad_enable", v, AV_OPT_SEARCH_CHILDREN));
				}

				// Long-Term Reference Frame Management
				if (auto v = obs_data_get_int(settings, ST_KEY_PA_LTR); v != -1) {
					TEST_AVERROR(av_opt_set_int(context, "pa_ltr_enable", v, AV_OPT_SEARCH_CHILDREN));
				}
			}
		}

		// Other Options
		{
			// B-Frames (H264 only)
			if (std::string_view{"h264_amf"} == codec->name) {
				if (auto v = obs_data_get_int(settings, ST_KEY_OTHER_BFRAMES); v != -1) {
					TEST_AVERROR(av_opt_set_int(context, "bf", v, AV_OPT_SEARCH_CHILDREN));
					TEST_AVERROR(av_opt_set_int(context, "max_b_frames", v, AV_OPT_SEARCH_CHILDREN));
				}
			}

			// The following do nothing in CQP, so we skip them entirely.
			if (!is_cqp(rc)) {
				// Variance Based Adaptive Quantization (non-AV1 only)
				if (auto v = obs_data_get_int(settings, ST_KEY_OTHER_VBAQ); avoption_exists(context->priv_data, "vbaq") && v != -1) {
					TEST_AVERROR(av_opt_set_int(context, "vbaq", v, AV_OPT_SEARCH_CHILDREN));
				}

				// High Quality Motion Boost
				if (auto v = obs_data_get_int(settings, ST_KEY_OTHER_HIGHMOTIONQUALITYBOOST); avoption_exists(context->priv_data, "high_quality_motion_boost_enable") && v != -1) {
					TEST_AVERROR(av_opt_set_int(context, "vbaq", v, AV_OPT_SEARCH_CHILDREN));
				}
			}

			if (auto v = obs_data_get_int(settings, ST_KEY_OTHER_REFERENCEFRAMES); v != -1) {
				context->refs = v;
				//TEST_AVERROR(av_opt_set_int(context, "refs", v, AV_OPT_SEARCH_CHILDREN));
			}
		}

		// Header Mode
		if (avoption_exists(context->priv_data, "header_spacing")) {
			TEST_AVERROR(av_opt_set_int(context, "header_spacing", context->keyint_min, AV_OPT_SEARCH_CHILDREN));
		} else if (avoption_exists(context->priv_data, "header_insertion_mode")) {
			TEST_AVERROR(av_opt_set(context, "header_insertion_mode", "gop", AV_OPT_SEARCH_CHILDREN));
		}

		// Access Unit Delimiter (H264, H265, H266)
		if (avoption_exists(context->priv_data, "aud")) {
			TEST_AVERROR(av_opt_set_int(context, "aud", 1, AV_OPT_SEARCH_CHILDREN));
		}
	}
}

void amf::override_update(ffmpeg_factory* factory, ffmpeg_instance* instance, obs_data_t* settings) {}

// H264/AVC Handler
//-------------------

static streamfx::encoder::ffmpeg::amf::avc inst_avc{};

amf::avc::avc() : handler("h264_amf") {}

amf::avc::~avc() {}

bool amf::avc::has_keyframes(ffmpeg_factory* factory)
{
	return true;
}

bool amf::avc::has_threading(ffmpeg_factory* factory)
{
	return false;
}

bool amf::avc::is_hardware(ffmpeg_factory* factory)
{
	return true;
}

bool amf::avc::is_reconfigurable(ffmpeg_factory* factory, bool& threads, bool& gpu, bool& keyframes)
{
	threads   = false;
	gpu       = false;
	keyframes = false;
	return true;
}

void amf::avc::adjust_info(ffmpeg_factory* factory, std::string& id, std::string& name, std::string& codec)
{
	name = "AMD AMF H264/AVC (via FFmpeg)";
	factory->get_info()->caps |= OBS_ENCODER_CAP_DYN_BITRATE;
#ifndef _DEBUG
	if ((obs_get_encoder_caps("h264_texture_amf") == 0) || (!amf::is_available())) {
		// If AMF is not present, or the default encoder is not present, don't list ours either.
		factory->get_info()->caps |= OBS_ENCODER_CAP_DEPRECATED | OBS_ENCODER_CAP_INTERNAL;
	}
#endif // _DEBUG
}

void amf::avc::defaults(ffmpeg_factory* factory, obs_data_t* settings)
{
	amf::defaults(factory, settings);
}

void amf::avc::properties(ffmpeg_factory* factory, ffmpeg_instance* instance, obs_properties_t* props)
{
	std::shared_ptr<AVCodecContext> context{avcodec_alloc_context3(factory->get_avcodec()), [](AVCodecContext* ptr) { avcodec_free_context(&ptr); }};
	amf::properties_before(factory, instance, props, context.get());

	{
		obs_properties_t* grp = props;
		if (!streamfx::util::are_property_groups_broken()) {
			grp = obs_properties_create();
			obs_properties_add_group(props, S_CODEC_H264, D_TRANSLATE(S_CODEC_H264), OBS_GROUP_NORMAL, grp);
		}

		{
			auto p = obs_properties_add_list(grp, ST_KEY_H264_PROFILE, D_TRANSLATE(S_CODEC_H264_PROFILE), OBS_COMBO_TYPE_LIST, OBS_COMBO_FORMAT_STRING);
			obs_property_list_add_string(p, D_TRANSLATE(S_STATE_DEFAULT), "");
			streamfx::ffmpeg::tools::avoption_list_add_entries(context->priv_data, "profile", [&p](const AVOption* opt) {
				char buffer[1024];
				snprintf(buffer, sizeof(buffer), "%s.%s", S_CODEC_H264_PROFILE, opt->name);
				obs_property_list_add_string(p, D_TRANSLATE(buffer), opt->name);
			});
		}
		{
			auto p = obs_properties_add_list(grp, ST_KEY_H264_LEVEL, D_TRANSLATE(S_CODEC_H264_LEVEL), OBS_COMBO_TYPE_LIST, OBS_COMBO_FORMAT_STRING);
			streamfx::ffmpeg::tools::avoption_list_add_entries(context->priv_data, "level", [&p](const AVOption* opt) {
				if (std::string_view{"auto"} == opt->name) {
					obs_property_list_add_string(p, D_TRANSLATE(S_STATE_AUTOMATIC), opt->name);
				} else {
					obs_property_list_add_string(p, opt->name, opt->name);
				}
			});
		}
	}

	amf::properties_after(factory, instance, props, context.get());
}

void amf::avc::migrate(ffmpeg_factory* factory, ffmpeg_instance* instance, obs_data_t* settings, uint64_t version)
{
	amf::migrate(factory, instance, settings, version);
}

void amf::avc::update(ffmpeg_factory* factory, ffmpeg_instance* instance, obs_data_t* settings)
{
	auto codec   = instance->get_avcodec();
	auto context = instance->get_avcodeccontext();

	TEST_AVERROR(av_opt_set(context->priv_data, "profile", obs_data_get_string(settings, ST_KEY_H264_PROFILE), AV_OPT_SEARCH_CHILDREN));
	TEST_AVERROR(av_opt_set(context->priv_data, "level", obs_data_get_string(settings, ST_KEY_H264_LEVEL), AV_OPT_SEARCH_CHILDREN));

	amf::update(factory, instance, settings);
}

void amf::avc::override_update(ffmpeg_factory* factory, ffmpeg_instance* instance, obs_data_t* settings)
{
	amf::override_update(factory, instance, settings);
}

void amf::avc::override_colorformat(ffmpeg_factory* factory, ffmpeg_instance* instance, obs_data_t* settings, AVPixelFormat& target_format) {}

// H265/HEVC Handler
//-------------------
static streamfx::encoder::ffmpeg::amf::hevc inst_hevc{};

amf::hevc::hevc() : handler("hevc_amf") {}

amf::hevc::~hevc() {}

bool amf::hevc::has_keyframes(ffmpeg_factory* factory)
{
	return true;
}

bool amf::hevc::has_threading(ffmpeg_factory* factory)
{
	return false;
}

bool amf::hevc::is_hardware(ffmpeg_factory* factory)
{
	return true;
}

bool amf::hevc::is_reconfigurable(ffmpeg_factory* factory, bool& threads, bool& gpu, bool& keyframes)
{
	threads   = false;
	gpu       = false;
	keyframes = false;
	return true;
}

void amf::hevc::adjust_info(ffmpeg_factory* factory, std::string& id, std::string& name, std::string& codec)
{
	name = "AMD AMF H265/HEVC (via FFmpeg)";
	factory->get_info()->caps |= OBS_ENCODER_CAP_DYN_BITRATE;
#ifndef _DEBUG
	if ((obs_get_encoder_caps("h265_texture_amf") == 0) || (!amf::is_available())) {
		// If AMF is not present, or the default encoder is not present, don't list ours either.
		factory->get_info()->caps |= OBS_ENCODER_CAP_DEPRECATED | OBS_ENCODER_CAP_INTERNAL;
	}
#endif // _DEBUG
}

void amf::hevc::defaults(ffmpeg_factory* factory, obs_data_t* settings)
{
	amf::defaults(factory, settings);
}

void amf::hevc::properties(ffmpeg_factory* factory, ffmpeg_instance* instance, obs_properties_t* props)
{
	std::shared_ptr<AVCodecContext> context{avcodec_alloc_context3(factory->get_avcodec()), [](AVCodecContext* ptr) { avcodec_free_context(&ptr); }};
	amf::properties_before(factory, instance, props, context.get());

	{
		obs_properties_t* grp = props;
		if (!streamfx::util::are_property_groups_broken()) {
			grp = obs_properties_create();
			obs_properties_add_group(props, S_CODEC_HEVC, D_TRANSLATE(S_CODEC_HEVC), OBS_GROUP_NORMAL, grp);
		}

		{
			auto p = obs_properties_add_list(grp, ST_KEY_H265_PROFILE, D_TRANSLATE(S_CODEC_HEVC_PROFILE), OBS_COMBO_TYPE_LIST, OBS_COMBO_FORMAT_STRING);
			obs_property_list_add_int(p, D_TRANSLATE(S_STATE_DEFAULT), -1);
			streamfx::ffmpeg::tools::avoption_list_add_entries(context->priv_data, "profile", [&p](const AVOption* opt) {
				char buffer[1024];
				snprintf(buffer, sizeof(buffer), "%s.%s", S_CODEC_HEVC_PROFILE, opt->name);
				obs_property_list_add_string(p, D_TRANSLATE(buffer), opt->name);
			});
		}
		{
			auto p = obs_properties_add_list(grp, ST_KEY_H265_TIER, D_TRANSLATE(S_CODEC_HEVC_TIER), OBS_COMBO_TYPE_LIST, OBS_COMBO_FORMAT_STRING);
			obs_property_list_add_string(p, D_TRANSLATE(S_STATE_DEFAULT), "default");
			streamfx::ffmpeg::tools::avoption_list_add_entries(context->priv_data, "profile_tier", [&p](const AVOption* opt) {
				char buffer[1024];
				snprintf(buffer, sizeof(buffer), "%s.%s", S_CODEC_HEVC_TIER, opt->name);
				obs_property_list_add_string(p, D_TRANSLATE(buffer), opt->name);
			});
		}
		{
			auto p = obs_properties_add_list(grp, ST_KEY_H265_LEVEL, D_TRANSLATE(S_CODEC_HEVC_LEVEL), OBS_COMBO_TYPE_LIST, OBS_COMBO_FORMAT_STRING);
			streamfx::ffmpeg::tools::avoption_list_add_entries(context->priv_data, "level", [&p](const AVOption* opt) {
				if (std::string_view{"auto"} == opt->name) {
					obs_property_list_add_string(p, D_TRANSLATE(S_STATE_AUTOMATIC), opt->name);
				} else {
					obs_property_list_add_string(p, opt->name, opt->name);
				}
			});
		}
	}

	amf::properties_after(factory, instance, props, context.get());
}

void amf::hevc::migrate(ffmpeg_factory* factory, ffmpeg_instance* instance, obs_data_t* settings, uint64_t version)
{
	amf::migrate(factory, instance, settings, version);
}

void amf::hevc::update(ffmpeg_factory* factory, ffmpeg_instance* instance, obs_data_t* settings)
{
	auto codec   = instance->get_avcodec();
	auto context = instance->get_avcodeccontext();

	TEST_AVERROR(av_opt_set(context->priv_data, "profile", obs_data_get_string(settings, ST_KEY_H265_PROFILE), AV_OPT_SEARCH_CHILDREN));
	TEST_AVERROR(av_opt_set(context->priv_data, "profile_tier", obs_data_get_string(settings, ST_KEY_H265_TIER), AV_OPT_SEARCH_CHILDREN));
	TEST_AVERROR(av_opt_set(context->priv_data, "level", obs_data_get_string(settings, ST_KEY_H265_LEVEL), AV_OPT_SEARCH_CHILDREN));

	amf::update(factory, instance, settings);
}

void amf::hevc::override_update(ffmpeg_factory* factory, ffmpeg_instance* instance, obs_data_t* settings)
{
	amf::override_update(factory, instance, settings);
}

void amf::hevc::override_colorformat(ffmpeg_factory* factory, ffmpeg_instance* instance, obs_data_t* settings, AVPixelFormat& target_format) {}

// AV1 Handler
//-------------------
static streamfx::encoder::ffmpeg::amf::av1 inst_av1{};

amf::av1::av1() : handler("av1_amf") {}

amf::av1::~av1() {}

bool amf::av1::has_keyframes(ffmpeg_factory* factory)
{
	return true;
}

bool amf::av1::has_threading(ffmpeg_factory* factory)
{
	return false;
}

bool amf::av1::is_hardware(ffmpeg_factory* factory)
{
	return true;
}

bool amf::av1::is_reconfigurable(ffmpeg_factory* factory, bool& threads, bool& gpu, bool& keyframes)
{
	threads   = false;
	gpu       = false;
	keyframes = false;
	return true;
}

void amf::av1::adjust_info(ffmpeg_factory* factory, std::string& id, std::string& name, std::string& codec)
{
	name = "AMD AMF AV1 (via FFmpeg)";
	factory->get_info()->caps |= OBS_ENCODER_CAP_DYN_BITRATE;
#ifndef _DEBUG
	if ((obs_get_encoder_caps("av1_texture_amf") == 0) || (!amf::is_available())) {
		// If AMF is not present, or the default encoder is not present, don't list ours either.
		factory->get_info()->caps |= OBS_ENCODER_CAP_DEPRECATED | OBS_ENCODER_CAP_INTERNAL;
	}
#endif // _DEBUG
}

void amf::av1::defaults(ffmpeg_factory* factory, obs_data_t* settings)
{
	amf::defaults(factory, settings);
}

void amf::av1::properties(ffmpeg_factory* factory, ffmpeg_instance* instance, obs_properties_t* props)
{
	std::shared_ptr<AVCodecContext> context{avcodec_alloc_context3(factory->get_avcodec()), [](AVCodecContext* ptr) { avcodec_free_context(&ptr); }};
	amf::properties_before(factory, instance, props, context.get());

	{
		obs_properties_t* grp = props;
		if (!streamfx::util::are_property_groups_broken()) {
			grp = obs_properties_create();
			obs_properties_add_group(props, S_CODEC_AV1, D_TRANSLATE(S_CODEC_AV1), OBS_GROUP_NORMAL, grp);
		}

		{
			auto p = obs_properties_add_list(grp, ST_KEY_AV1_PROFILE, D_TRANSLATE(S_CODEC_AV1_PROFILE), OBS_COMBO_TYPE_LIST, OBS_COMBO_FORMAT_STRING);
			obs_property_list_add_string(p, D_TRANSLATE(S_STATE_DEFAULT), "default");
			streamfx::ffmpeg::tools::avoption_list_add_entries(context->priv_data, "profile", [&p](const AVOption* opt) {
				char buffer[1024];
				snprintf(buffer, sizeof(buffer), "%s.%s", S_CODEC_AV1_PROFILE, opt->name);
				obs_property_list_add_string(p, D_TRANSLATE(buffer), opt->name);
			});
		}
		{
			auto p = obs_properties_add_list(grp, ST_KEY_AV1_LEVEL, D_TRANSLATE(S_CODEC_AV1_LEVEL), OBS_COMBO_TYPE_LIST, OBS_COMBO_FORMAT_STRING);
			streamfx::ffmpeg::tools::avoption_list_add_entries(context->priv_data, "level", [&p](const AVOption* opt) {
				if (std::string_view{"auto"} == opt->name) {
					obs_property_list_add_string(p, D_TRANSLATE(S_STATE_AUTOMATIC), opt->name);
				} else {
					obs_property_list_add_string(p, opt->name, opt->name);
				}
			});
		}
	}

	amf::properties_after(factory, instance, props, context.get());
}

void amf::av1::migrate(ffmpeg_factory* factory, ffmpeg_instance* instance, obs_data_t* settings, uint64_t version)
{
	amf::migrate(factory, instance, settings, version);
}

void amf::av1::update(ffmpeg_factory* factory, ffmpeg_instance* instance, obs_data_t* settings)
{
	auto codec   = instance->get_avcodec();
	auto context = instance->get_avcodeccontext();

	TEST_AVERROR(av_opt_set(context->priv_data, "profile", obs_data_get_string(settings, ST_KEY_AV1_PROFILE), AV_OPT_SEARCH_CHILDREN));
	TEST_AVERROR(av_opt_set(context->priv_data, "level", obs_data_get_string(settings, ST_KEY_AV1_LEVEL), AV_OPT_SEARCH_CHILDREN));

	amf::update(factory, instance, settings);
}

void amf::av1::override_update(ffmpeg_factory* factory, ffmpeg_instance* instance, obs_data_t* settings)
{
	amf::override_update(factory, instance, settings);
}

void amf::av1::override_colorformat(ffmpeg_factory* factory, ffmpeg_instance* instance, obs_data_t* settings, AVPixelFormat& target_format) {}
